module map;

import std.stdio;
import std.conv;
import std.xml;
import std.file;

import derelict.sdl.sdl;

debug {
  import std.datetime;
}

version(unittest) {
  import derelict.sdl.sdl;
  import derelict.sdl.image;
  import derelict.util.compat;
}

import constants, tile, surface;
import resource.image;

/**
 * A tile-based drawable grid with helper functions.
 */
class Map {
  private TileSet _tileSet;
  int[] _tileList;

  TileSet getTileSet() {
    return _tileSet;
  }

  void setTileSet(TileSet tileSet) {
    _tileSet = tileSet;
  }

  /**
   * Load a map from a TMX file in XML format.
   * The file format is that generated by the program 'tiled'.
   *
   * See http://www.mapeditor.org
   */
  bool loadFromTmxFile(string fileName) {
    debug StopWatch sw = StopWatch(AutoStart.yes);
    string xmlData = cast(string)std.file.read(fileName);
    debug writeln("Read ", fileName, " in ", sw.peek().msecs, "ms.");

    return loadFromTmx(xmlData);
  }

  bool loadFromTmx(string xmlData) {
    _tileSet = new TileSet();
    _tileList.length = 0;

    string tileSetImageName;
    int imageWidth;
    int imageHeight;
    int tileWidth;
    int tileHeight;

    debug StopWatch sw = StopWatch(AutoStart.yes);
    // Check for XML syntax compliance.
    //debug check(xmlData); // Validating takes around 26s.
    //debug writeln("Verified XML in ", sw.peek.msecs, "ms.");

    auto xml = new DocumentParser(xmlData);

    xml.onStartTag["tileset"] = (ElementParser xml) {
      tileWidth = to!int(xml.tag.attr["tilewidth"]);
      tileHeight = to!int(xml.tag.attr["tileheight"]);
      // Read out image information.
      xml.onEndTag["image"] = (in Element e) {
        imageWidth = to!int(e.tag.attr["width"]);
        imageHeight = to!int(e.tag.attr["height"]);
        tileSetImageName = e.tag.attr["source"];

        // Initialize our tiles (not all will have properties).
        int numTiles = imageHeight / tileHeight * imageWidth / tileWidth;
        _tileSet.tiles.length = numTiles;
        foreach (id, ref tile; _tileSet.tiles) {
          tile = new Tile();
          tile.id = id;
        }
      };
      // Read all tiles.
      xml.onStartTag["tile"] = (ElementParser xml) {
        int id = to!int(xml.tag.attr["id"]);

        // Skip to the property we want.
        xml.onStartTag["property"] = (ElementParser xml) {
          if ("name" in xml.tag.attr && xml.tag.attr["name"] == "type" &&
              "value" in xml.tag.attr) {
            _tileSet.tiles[id].type = cast(Tile.Type) to!int(xml.tag.attr["value"]);
          }
        };
        xml.parse();
      };
      xml.parse();
    };

    // Parse the layer, which specifies which tiles cover the map.
    xml.onStartTag["layer"] = (ElementParser xml) {
      // First set aside enough room for our tiles.
      int width = to!int(xml.tag.attr["width"]);
      int height = to!int(xml.tag.attr["height"]);
      _tileList.length = width * height;

      int id = 0;

      // Read each tile out and get the id used to reference the TileSet.
      xml.onEndTag["tile"] = (in Element e) {
        _tileList[id] = to!int(e.tag.attr["gid"]) - 1;
        id++;
      };
      xml.parse();
    };

    debug sw = StopWatch(AutoStart.yes);
    xml.parse();
    debug writeln("Parsed XML in ", sw.peek.msecs, "ms.");

    if (tileSetImageName.length == 0)
      throw new Exception("MapFile missing source attribute in image tag!");

    debug writeln("Loading image: ", tileSetImageName);
    _tileSet.surface = ImageBank.IMAGES[tileSetImageName];

    return true;
  }

  unittest {
    string testXmlData = q"EOF
<?xml version="1.0" encoding="UTF-8"?>
<map version="1.0" orientation="orthogonal" width="40" height="40" tilewidth="16" tileheight="16">
 <tileset firstgid="1" name="DemoTileSet" tilewidth="16" tileheight="16">
  <image source="./tileset/1.png" width="64" height="48"/>
  <tile id="0">
   <properties>
    <property name="type" value="1"/>
   </properties>
  </tile>
  <tile id="1">
   <properties>
    <property name="type" value="1"/>
   </properties>
  </tile>
 </tileset>
 <layer name="Tile Layer 1" width="2" height="2">
   <data>
     <tile gid="2"/>
     <tile gid="1"/>
     <tile gid="2"/>
     <tile gid="1"/>
   </data>
 </layer>
</map>
EOF";

    DerelictSDL.load();
    DerelictSDLImage.load();

    if (SDL_Init(SDL_INIT_VIDEO) < 0)
    {
      throw new Exception("Couldn't init SDL: " ~ toDString(SDL_GetError()));
    }

    Map map = new Map();
    map.loadFromTmx(testXmlData);
    TileSet tileSet = map.getTileSet();
  
    assert(tileSet !is null, "Returned null value.");
    assert(tileSet.tiles.length == 12, "Incorrect 'tiles.length'.");
    assert(tileSet.tiles[0].id == 0);
    assert(tileSet.tiles[1].type == Tile.Type.NORMAL, "Incorrect type " ~ to!string(tileSet.tiles[1].type));
    assert(tileSet.tiles[2].type == Tile.Type.NONE, "Bad default type " ~ to!string(tileSet.tiles[2].type));

    assert(map._tileList[0] == 1, "tileList[0] == 1, found " ~ to!string(map._tileList[0]));
    assert(map._tileList.length == 4, "_tileList.length == 4, found " ~ to!string(map._tileList.length));

    SDL_Quit();
  }

  void onRender(SDL_Surface* surfDisplay, int mapX, int mapY) {
    if (_tileSet.surface == null) return;

    int tilesetWidth = _tileSet.surface.w / TILE_SIZE;
    int tilesetHeight = _tileSet.surface.h / TILE_SIZE;

    int id = 0;

    foreach (y; 0 .. MAP_HEIGHT) {
      foreach (x; 0 .. MAP_WIDTH) {
        // Get the tile to draw from the TileSet using its id from the tileList.
        Tile tile = _tileSet.tiles[_tileList[id]];

        if (tile.type == Tile.Type.NONE) {
          id++;
          continue;
        }

        int tX = mapX + (x * TILE_SIZE);
        int tY = mapY + (y * TILE_SIZE);

        int tilesetX = (tile.id % tilesetWidth) * TILE_SIZE;
        int tilesetY = (tile.id / tilesetWidth) * TILE_SIZE;

        Surface.onDraw(
          _tileSet.surface, tilesetX, tilesetY, TILE_SIZE, TILE_SIZE,
          surfDisplay, tX, tY);

        id++;
      }
    }
  }

  /**
   * Gets the tile from coordinates relative to the map.
   */
  Tile getTile(int x, int y) {
    int id = x / TILE_SIZE + y / TILE_SIZE * MAP_WIDTH;

    if (id < 0 || id >= _tileList.length)
      return null;

    if (_tileList[id] < 0 || _tileList[id] >= _tileSet.tiles.length) {
      writeln("Tile ", _tileList[id], " is out of range ", _tileSet.tiles.length);
    }
    return _tileSet.tiles[_tileList[id]];
  }
}
