module map;

import std.conv : to;
import std.xml : DocumentParser, ElementParser, Element;
import std.file : read;
import std.algorithm : min, max;

import graphics;

debug {
  import std.datetime : StopWatch, AutoStart;
  import std.string : fromStringz;
  import std.stdio : writeln, writefln;
}

import tile;

/**
 * A tile-based drawable grid with helper functions.
 */
class Map {
  private TileSet _tileSet;
  int[] _tileList;
  int mapWidth;
  int mapHeight;
  int tileWidth;
  int tileHeight;

  TileSet getTileSet() {
    return _tileSet;
  }

  void setTileSet(TileSet tileSet) {
    _tileSet = tileSet;
  }

  /**
   * Load a map from a TMX file in XML format.
   * The file format is that generated by the program 'tiled'.
   *
   * See http://www.mapeditor.org
   */
  bool loadFromTmxFile(string fileName, ImageLoader imageLoader) {
    debug StopWatch sw = StopWatch(AutoStart.yes);
    string xmlData = cast(string)read(fileName);
    debug writeln("Read ", fileName, " in ", sw.peek().msecs, "ms.");

    return loadFromTmx(imageLoader, xmlData);
  }

  bool loadFromTmx(ImageLoader imageLoader, string xmlData) {
    _tileSet = new TileSet();
    _tileList.length = 0;

    string tileSetImageName;
    int imageWidth;
    int imageHeight;

    debug StopWatch sw = StopWatch(AutoStart.yes);
    // Check for XML syntax compliance.
    //debug check(xmlData); // Validating takes around 26s.
    //debug writeln("Verified XML in ", sw.peek.msecs, "ms.");

    auto xml = new DocumentParser(xmlData);
    xml.onStartTag["tileset"] = (ElementParser xml) {
      tileWidth = to!int(xml.tag.attr["tilewidth"]);
      tileHeight = to!int(xml.tag.attr["tileheight"]);
      // Read out image information.
      xml.onEndTag["image"] = (in Element e) {
        imageWidth = to!int(e.tag.attr["width"]);
        imageHeight = to!int(e.tag.attr["height"]);
        tileSetImageName = e.tag.attr["source"];

        // Initialize our tiles (not all will have properties).
        int numTiles = imageHeight / tileHeight * imageWidth / tileWidth;
        _tileSet.tiles.length = numTiles;
        foreach (int id, ref tile; _tileSet.tiles) {
          tile = new Tile();
          tile.id = id;
        }
      };
      // Read all tiles.
      xml.onStartTag["tile"] = (ElementParser xml) {
        int id = to!int(xml.tag.attr["id"]);

        // Skip to the property we want.
        xml.onStartTag["property"] = (ElementParser xml) {
          if ("name" in xml.tag.attr && xml.tag.attr["name"] == "type" &&
              "value" in xml.tag.attr) {
            _tileSet.tiles[id].type = cast(Tile.Type) to!int(xml.tag.attr["value"]);
          }
        };
        xml.parse();
      };
      xml.parse();
    };

    // Parse the layer, which specifies which tiles cover the map.
    xml.onStartTag["layer"] = (ElementParser xml) {
      // First set aside enough room for our tiles.
      mapWidth = to!int(xml.tag.attr["width"]);
      mapHeight = to!int(xml.tag.attr["height"]);
      _tileList.length = mapWidth * mapHeight;

      int id = 0;

      // Read each tile out and get the id used to reference the TileSet.
      xml.onEndTag["tile"] = (in Element e) {
        _tileList[id] = to!int(e.tag.attr["gid"]) - 1;
        id++;
      };
      xml.parse();
    };

    debug sw = StopWatch(AutoStart.yes);
    xml.parse();
    debug writeln("Parsed XML in ", sw.peek.msecs, "ms.");

    if (tileSetImageName.length == 0)
      throw new Exception("MapFile missing source attribute in image tag!");

    debug writeln("Loading image: ", tileSetImageName);
    _tileSet.image = imageLoader.load(tileSetImageName);

    return true;
  }

  /**
   * Params:
   *   surfDisplay = The surface to draw the map upon.
   *   mapX = The horizontal offset to begin drawing the map.
   *   mapY = The vertical offset to begin drawing the map.
   */
  void render(Display display, int mapX, int mapY)
    in {
      assert(_tileSet.image != Image.init);
    }
  body {
    int tilesetWidth = _tileSet.image.width / tileWidth;
    int tilesetHeight = _tileSet.image.height / tileHeight;

    int id = 0;

    foreach (y; 0 .. mapHeight) {
      int tY = mapY + (y * tileHeight);
      foreach (x; 0 .. mapWidth) {
        int tX = mapX + (x * tileWidth);
        // Get the tile to draw from the TileSet using its id from the tileList.
        Tile tile = _tileSet.tiles[_tileList[id]];

        if (tile.type == Tile.Type.NONE || tX + tileWidth <= 0 || tX >= display.width ||
            tY + tileHeight <= 0 || tY >= display.height) {
          id++;
          continue;
        }

        int srcX = (tile.id % tilesetWidth) * tileWidth + max(0, -tX);
        int srcY = (tile.id / tilesetWidth) * tileHeight + max(0, -tY);
        int srcWidth = tileWidth - max(0, -tX);
        int srcHeight = tileHeight - max(0, -tY);

        display.renderImage(max(tX, 0), max(tY, 0),
            _tileSet.image, srcX, srcY,
            min(srcWidth, display.width - tX), min(srcHeight, display.height - tY));

        id++;
      }
    }
  }

  /**
   * Gets the tile from coordinates relative to the map.
   */
  Tile getTile(int x, int y) {
    int id = x / tileWidth + y / tileHeight * mapWidth;

    if (id < 0 || id >= _tileList.length)
      return null;

    if (_tileList[id] < 0 || _tileList[id] >= _tileSet.tiles.length) {
      debug writeln("Tile ", _tileList[id], " is out of range ", _tileSet.tiles.length);
    }
    return _tileSet.tiles[_tileList[id]];
  }
}

unittest {
  writeln("-- START UnitTest for Map --");
  string testXmlData = q"EOF
<?xml version="1.0" encoding="UTF-8"?>
<map version="1.0" orientation="orthogonal" width="3" height="4" tilewidth="16" tileheight="16">
 <tileset firstgid="1" name="DemoTileSet" tilewidth="16" tileheight="16">
  <image source="./tileset/1.png" width="64" height="48"/>
  <tile id="0">
   <properties>
    <property name="type" value="1"/>
   </properties>
  </tile>
  <tile id="1">
   <properties>
    <property name="type" value="1"/>
   </properties>
  </tile>
  <tile id="2">
   <properties>
    <property name="type" value="2"/>
   </properties>
  </tile>
 </tileset>
 <layer name="Tile Layer 1" width="3" height="4">
   <data>
     <tile gid="2"/>
     <tile gid="1"/>
     <tile gid="2"/>
     <tile gid="1"/>
     <tile gid="2"/>
     <tile gid="1"/>
     <tile gid="2"/>
     <tile gid="3"/>
     <tile gid="2"/>
     <tile gid="1"/>
     <tile gid="2"/>
     <tile gid="1"/>
   </data>
 </layer>
</map>
EOF";

  ImageLoader imageLoader = new ImageLoader(null /* renderer */);
  imageLoader.cache(
      "./tileset/1.png", Image(null /* texture */, 64 /* width */, 48 /* height */));

  Map map = new Map();
  map.loadFromTmx(imageLoader, testXmlData);
  TileSet tileSet = map.getTileSet();

  assert(tileSet !is null, "Returned null value.");
  assert(tileSet.tiles.length == 12, "Incorrect 'tiles.length'.");
  assert(tileSet.tiles[0].id == 0);
  assert(tileSet.tiles[1].type == Tile.Type.NORMAL, "Incorrect type " ~ to!string(tileSet.tiles[1].type));
  assert(tileSet.tiles[2].type == Tile.Type.BLOCK, "Incorrect type " ~ to!string(tileSet.tiles[2].type));
  assert(tileSet.tiles[3].type == Tile.Type.NONE, "Bad default type " ~ to!string(tileSet.tiles[3].type));

  assert(map._tileList.length == 12);
  assert(map._tileList[0] == 1, "tileList[0] == 1, found " ~ to!string(map._tileList[0]));

  assert(map.getTile(18, 35).type == 2);
  assert(map.getTile(15, 35).type == 1);
  assert(map.getTile(35, 35).type == 1);
  assert(map.getTile(35, 31).type == 1);
  assert(map.getTile(35, 49).type == 1);
  writeln("-- END UnitTest for Map --");
}

